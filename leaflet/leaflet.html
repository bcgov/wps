<html>
  <head>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
      integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
      crossorigin=""
    />
    <script
      src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
      integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
      crossorigin=""
    ></script>
    <style type="text/css">
      #mapid {
        height: 640px;
      }
    </style>
  </head>
  <body>
    <div id="mapid"></div>
    model date:
    <input id="model_run_timestamp" value="2021-01-18T00:00:00.000Z"></div>
    prediction date:
    <div id="prediction_timestamp"></div>
    <button onclick="fetchPreviousTimestamp()">
      Previous:
      <div id="previous_prediction_timestamp"></div>
    </button>
    <button onclick="fetchNextTimestamp()">
      Next:
      <div id="next_prediction_timestamp"></div>
    </button>
    <script type="text/javascript">
      function getFormattedGDPSTimestamp(timestamp) {
        const year = timestamp.getUTCFullYear();
        const month = (timestamp.getUTCMonth() + 1).toString().padStart(2, "0");
        const day = timestamp.getUTCDate().toString().padStart(2, "0");
        const hours =
          timestamp.getUTCHours() % 3 == 0
            ? timestamp.getUTCHours()
            : timestamp.getUTCHours() - (timestamp.getUTCHours() % 3);
        return `${year}-${month}-${day}T${hours
          .toString()
          .padStart(2, "0")}:00:00.000Z`;
      }

      function fetchLayer(map, model_run_timestamp, prediction_timestamp) {
        let xhr = new XMLHttpRequest();
        // xhr.open(
        //   "GET",
        //   "/api/c-haines/?model_run_timestamp=" +
        //     model_run_timestamp +
        //     "&prediction_timestamp=" +
        //     getFormattedGDPSTimestamp(prediction_timestamp)
        // );
        xhr.open(
          "GET",
          "/api/c-haines/?model_run_timestamp=" +
            model_run_timestamp +
            "&prediction_timestamp=" +
            '2021-01-23T03:00:00.000Z'
        );
        xhr.setRequestHeader("Content-Type", "application/json");
        xhr.responseType = "json";
        xhr.onload = function () {
          if (xhr.status !== 200) return;
          const geoJsonLayer = L.geoJSON(xhr.response, {
            style: function (feature) {
              switch (feature.properties.severity) {
                case 1:
                  // yellow
                  return { color: "#ffff00" };
                case 2:
                  return { color: "#FFA500" };
                case 3:
                  // red
                  return { color: "#ff0000" };
                  // return { color: "#800080" }; // purple
              }
            },
          });
          if (currentLayer != null) {
            map.removeLayer(currentLayer);
          }
          geoJsonLayer.addTo(map);
          currentLayer = geoJsonLayer;

          window["prediction_timestamp"] = prediction_timestamp;
          next_prediction_timestamp = new Date(prediction_timestamp);
          next_prediction_timestamp.setHours(
            next_prediction_timestamp.getHours() + 3
          );
          window["next_prediction_timestamp"] = next_prediction_timestamp;
          updateHTML();
        };
        xhr.send();
      }

      function fetchPreviousTimestamp() {
        fetchLayer(mymap, document.getElementById("model_run_timestamp").value, _prediction_timestamp);
      }

      function fetchNextTimestamp() {
        fetchLayer(mymap, document.getElementById("model_run_timestamp").value, next_prediction_timestamp);
      }

      function getNextTimestamp(timestamp) {
        let next_prediction_timestamp = new Date(timestamp);
        next_prediction_timestamp.setHours(
          next_prediction_timestamp.getHours() + 3
        );
        return next_prediction_timestamp;
      }

      function getPreviousTimestamp(timestamp) {
        let previous_prediction_timestamp = new Date(timestamp);
        previous_prediction_timestamp.setHours(
          previous_prediction_timestamp.getHours() - 3
        );
        return previous_prediction_timestamp;
      }

      function updateHTML() {
        document.getElementById(
          "prediction_timestamp"
        ).innerText = getFormattedGDPSTimestamp(window["prediction_timestamp"]);
        document.getElementById(
          "next_prediction_timestamp"
        ).innerText = getFormattedGDPSTimestamp(next_prediction_timestamp);
        document.getElementById(
          "previous_prediction_timestamp"
        ).innerText = getFormattedGDPSTimestamp(
          window["previous_prediction_timestamp"]
        );
      }

      var mymap = L.map("mapid").setView([0, 0], 1);
      const streetLayer = L.tileLayer(
        "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
        {
          attribution:
            '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors',
        }
      );
      streetLayer.addTo(mymap);

      let currentLayer = null;

      let prediction_timestamp = new Date();
      window["prediction_timestamp"] = prediction_timestamp;
      let next_prediction_timestamp = getNextTimestamp(prediction_timestamp);
      let previous_prediction_timestamp = getPreviousTimestamp(
        prediction_timestamp
      );
      window["previous_prediction_timestamp"] = previous_prediction_timestamp;
      fetchLayer(mymap, document.getElementById("model_run_timestamp").value, prediction_timestamp);
    </script>
  </body>
</html>
