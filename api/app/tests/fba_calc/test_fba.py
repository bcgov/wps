"""
Unit tests for fire behavour calculator.

NOTE: Regarding the json files used in these tests:
The JSON request files were manually generated referencing requests generated by the user interface by
inspecting the network tab.
The JSON response files were generated by copying the "actual" output of the tests.
Running the test with this syntax `pytest app/tests/fba/test_fba.py -s` will result in actual vs. expected
JSON to be printed out to screen. If the tests are failing, a developer can inspect the JSON and establish
if the change in output is due to a bug, or due to a valid change.
"""
import json
from typing import Tuple
from pytest_bdd import scenario, given, then, parsers
from fastapi.testclient import TestClient
from aiohttp import ClientSession
import pytest
import app.main
from app.tests.common import default_mock_client_get
from app.tests import load_json_file, load_json_file_with_name


@pytest.mark.usefixtures('mock_jwt_decode')
@scenario('test_fba.feature', 'Fire Behaviour Calculation')
def test_fire_behaviour_calculator_scenario():
    """ BDD Scenario. """


@given(parsers.parse("I received a {request_json}"),
       target_fixture='result',
       converters={'request_json': load_json_file_with_name(__file__)})
def given_request(monkeypatch, request_json: Tuple[dict, str]):
    """ Handle request
    Our request should result in
    1) station list requests to WFWX, to map station codes to GUIDs.
    2) dailies call to WFWX.
    3) call to the R code to calculate values.
    """
    # mock anything that uses aiohttp.ClientSession::get
    monkeypatch.setattr(ClientSession, 'get', default_mock_client_get)

    client = TestClient(app.main.app)
    headers = {'Content-Type': 'application/json',
               'Authorization': 'Bearer token'}
    return {
        'response': client.post('/api/fba-calc/stations', headers=headers, json=request_json[0]),
        'filename': request_json[1]
    }


@then(parsers.parse("the response status code is {status_code}"), converters={'status_code': int})
def then_status(result, status_code: int):
    """ Check response status code """
    assert result['response'].status_code == status_code, result['filename']


@then(parsers.parse("the response is {response_json}"),
      converters={'response_json': load_json_file(__file__)})
def then_response(result, response_json: dict):
    """ Check entire response """
    if response_json is not None:
        print('actual:\n{}'.format(json.dumps(result['response'].json(), indent=4)))
        print('expected:\n{}'.format(json.dumps(response_json, indent=4)))
        assert result['response'].json() == response_json, result['filename']
